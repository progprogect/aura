# Унификация покупки услуг: через заявки и прямая покупка

## Цель документа

Описывает архитектуру и требования для унификации процесса покупки услуг: **прямая покупка должна работать точно так же, как покупка через заявку с немедленным выбором специалиста**.

## Текущее состояние

### Система через заявки (Requests)

**Flow:**
1. Клиент создает заявку (`UserRequest`, status='open')
2. Специалисты видят заявку и отправляют отклики (`Proposal`)
3. Клиент выбирает специалиста (принимает `Proposal`)
4. При принятии отклика:
   - Создается временная `Service` через `createTemporaryServiceForRequest`
   - Создается `Order` со статусом `paid`, `pointsFrozen=true`, связь с `requestId`
   - Обновляется `UserRequest` (status='in_progress', `selectedSpecialistId`, `orderId`)
   - Списываются баллы через `PointsService.deductPoints`
   - Отправляется SMS уведомление специалисту через `notifySpecialistAboutAcceptedProposal`

**API:** `PATCH /api/proposals/[id]/accept`

### Система прямой покупки (Direct Purchase)

**Flow:**
1. Клиент покупает услугу напрямую через страницу услуги
2. При покупке:
   - Списываются баллы ВНУТРИ транзакции через `PointsService.deductPoints`
   - Создается `Order` со статусом `paid`, `pointsFrozen=true`, **БЕЗ** связи с `requestId`
   - **НЕТ** создания/обновления `UserRequest`
   - **НЕТ** уведомления специалисту (TODO в коде)

**API:** `POST /api/orders/create-with-points`

### Различия (проблемы)

| Аспект | Через заявку | Прямая покупка | Консистентность |
|--------|--------------|----------------|-----------------|
| Создание `Order` | ✅ status='paid', pointsFrozen=true | ✅ status='paid', pointsFrozen=true | ✅ Одинаково |
| Связь с `UserRequest` | ✅ Есть `requestId` | ❌ Нет `requestId` | ❌ **Разное** |
| Уведомление специалисту | ✅ `notifySpecialistAboutAcceptedProposal` | ❌ Нет (TODO) | ❌ **Разное** |
| Списывание баллов | ✅ После создания Order | ✅ Внутри транзакции | ✅ Одинаково (но порядок разный) |
| Создание Service | ✅ Временная через `createTemporaryServiceForRequest` | ✅ Используется существующая | ⚠️ Разное (но это ок) |

## Целевое состояние (Требования)

### Принцип унификации

**Прямая покупка должна работать как: "Клиент создал заявку → сразу выбрал специалиста"**

### Сценарии использования

#### Сценарий 1: Прямая покупка услуги

**Актеры:** Клиент, Специалист

**Предусловия:**
- Клиент авторизован
- У клиента достаточно баллов
- Услуга активна
- Специалист принимает клиентов (`acceptingClients=true`)

**Основной поток:**
1. Клиент переходит на страницу услуги специалиста
2. Клиент заполняет форму заказа (имя, контакт, сообщение)
3. Клиент подтверждает покупку
4. **Система создает Order:**
   - status='paid'
   - pointsFrozen=true
   - pointsUsed=<цена услуги>
   - autoConfirmAt = now() + 7 дней
   - deadline = now() + deliveryDays (если указан)
   - requestId = null (прямая покупка, не через заявку)
5. **Система списывает баллы** (замораживание) внутри транзакции
6. **Система отправляет уведомление специалисту** (общее уведомление)
7. Специалист получает заказ в своем дашборде (все заказы показываются независимо от источника)
8. Специалист выполняет работу и отмечает как завершенную
9. Клиент подтверждает выполнение
10. Баллы переходят специалисту

**Альтернативные потоки:**
- 3a. Недостаточно баллов → показывается ошибка с предложением пополнить баланс
- 3b. Услуга неактивна → показывается ошибка
- 3c. Специалист не принимает клиентов → показывается ошибка

#### Сценарий 2: Покупка через заявку (существующий flow, без изменений)

**Актеры:** Клиент, Специалист

**Предусловия:** Те же

**Основной поток:**
1. Клиент создает заявку через квиз
2. Специалисты видят заявку и отправляют отклики
3. Клиент выбирает специалиста
4. Принимается отклик → создается Order (как сейчас)
5. Остальной flow идентичен сценарию 1

### Архитектурные решения

#### Решение 1: Опциональный `requestId` (принято)

**Принятое решение:** Использовать опциональный `requestId` в модели `Order`. Это уже поддерживается схемой БД и существующим кодом.

**Преимущества:**
- ✅ Соответствует реальной модели данных: не все заказы идут через заявку
- ✅ Минимальные изменения в коде: проверки `if (order.requestId)` уже существуют
- ✅ Простота: не создаем лишние сущности
- ✅ Чистая архитектура: каждая сущность по своему назначению
- ✅ Специалист видит все заказы в дашборде независимо от источника

**Текущее состояние кода:**
Проверки `requestId` уже существуют в двух местах:
- `src/app/api/orders/[id]/confirm/route.ts` (строки 107-114)
- `src/app/api/orders/[id]/complete/route.ts` (строки 106-113)

Эти проверки обновляют статус связанной заявки только если она существует.

#### Решение 2: Унификация уведомлений

**Проблема:** При прямой покупке нет уведомления специалисту.

**Решение:** Использовать существующую функцию `notifySpecialistAboutAcceptedProposal` или создать общую функцию `notifySpecialistAboutNewOrder` с **общим текстом уведомления** (без кастомизации для разных источников).

```typescript
// Создать общую функцию уведомлений
notifySpecialistAboutNewOrder(
  specialistUserId: string,
  clientName: string,
  orderTitle: string,
  orderPrice: number
)
```

**Обоснование:**
- Единый текст уведомления для всех заказов упрощает поддержку
- Источник заказа (прямая покупка или заявка) не критичен для специалиста
- При необходимости можно добавить кастомизацию позже

**Использование:**
- В `proposals/[id]/accept` — принять отклик → создать Order с requestId
- В `orders/create-with-points` — прямая покупка → создать Order без requestId

#### Решение 3: Унификация порядка операций

**Текущая проблема:** При принятии отклика баллы списываются ПОСЛЕ создания Order, при прямой покупке — ВНУТРИ транзакции.

**Решение:** Унифицировать на списание ВНУТРИ транзакции создания Order для консистентности и надежности:

```typescript
await prisma.$transaction(async (tx) => {
  // 1. Списываем баллы (ВНУТРИ транзакции)
  await PointsService.deductPoints(...)
  
  // 2. Создаем Order
  const order = await tx.order.create({ ... })
  
  // 3. Обновляем Request (если есть)
  if (requestId) {
    await tx.userRequest.update({ ... })
  }
})
```

**Преимущества:**
- ✅ Атомарность: либо все, либо ничего
- ✅ Консистентность между двумя способами покупки
- ✅ Безопасность: нет риска создать Order без списания баллов
- ✅ Правильный порядок: сначала списание, потом создание Order

**Важно:** `PointsService.deductPoints` может работать вне транзакции, но должен вызываться до создания Order для консистентности логики.

## Трассировка требований

### Функциональные требования

| ID | Требование | Приоритет | Зависимости |
|----|------------|-----------|-------------|
| FR-1 | При прямой покупке отправлять уведомление специалисту | Высокий | FR-3 |
| FR-2 | Унифицировать порядок операций: списание баллов внутри транзакции | Средний | - |
| FR-3 | Создать общую функцию уведомлений для заказов (с общим текстом) | Средний | - |
| FR-4 | Обеспечить одинаковый статус Order при обоих способах покупки | Высокий | - |
| FR-5 | Обеспечить одинаковое замораживание баллов при обоих способах | Высокий | FR-2 |
| FR-6 | Обеспечить отображение всех заказов в дашборде специалиста (независимо от источника) | Высокий | - |

### Нефункциональные требования

| ID | Требование | Приоритет |
|----|------------|-----------|
| NFR-1 | Изменения не должны ломать существующий функционал заявок | Критический |
| NFR-2 | Код должен быть легко поддерживаемым и масштабируемым | Высокий |
| NFR-3 | Интерфейс должен оставаться простым (не усложнять UX) | Высокий |
| NFR-4 | Производительность не должна ухудшиться | Средний |

## Изменения в коде

### 1. API: `/api/orders/create-with-points`

**Файл:** `src/app/api/orders/create-with-points/route.ts`

**Изменения:**
1. Отправлять уведомление специалисту после создания Order
2. Убедиться, что `requestId` остается `null` (прямая покупка)
3. Унифицировать порядок операций: списание баллов до создания Order (внутри транзакции)

**Зависимости:**
- Новая общая функция уведомлений `notifySpecialistAboutNewOrder`
- Используется существующая Service (не нужно создавать временную)

### 2. Новый модуль: Унифицированные уведомления

**Файл:** `src/lib/notifications/order-notifications.ts` (новый)

**Функции:**
- `notifySpecialistAboutNewOrder(specialistUserId, clientName, orderTitle, orderPrice)` — общая функция уведомлений с единым текстом

**Использование:**
- Заменить вызов `notifySpecialistAboutAcceptedProposal` в `proposals/[id]/accept`
- Добавить вызов в `orders/create-with-points`

### 3. API: `/api/proposals/[id]/accept`

**Файл:** `src/app/api/proposals/[id]/accept/route.ts`

**Изменения:**
1. Переместить списание баллов внутрь транзакции (для консистентности)
2. Использовать новую общую функцию уведомлений

### 4. Схема БД: Без изменений

**Файл:** `prisma/schema.prisma`

**Статус:** ✅ Не требуется изменений

Все необходимые поля уже есть:
- `Order.requestId` — опциональный (`String?`), уже поддерживает связь с заявкой
- Существующие проверки `if (order.requestId)` в коде обрабатывают оба случая корректно

### 5. UI: Без изменений

**Файлы:**
- `src/components/services/OrderForm.tsx`
- `src/app/specialist/[slug]/services/[serviceSlug]/page.tsx`

**Статус:** ✅ Не требуется изменений

UX остается прежним, изменения только в бэкенде.

## Детальный план реализации

### Этап 1: Подготовка (1 час)

1. Протестировать существующий flow заявок (регрессионное тестирование)
2. Документировать текущее поведение
3. Изучить существующий код уведомлений

### Этап 2: Унификация уведомлений (1-2 часа)

1. Создать общую функцию `notifySpecialistAboutNewOrder` с единым текстом
2. Обновить оба API endpoint:
   - `proposals/[id]/accept` — заменить на новую функцию
   - `orders/create-with-points` — добавить вызов новой функции
3. Протестировать уведомления для обоих сценариев

### Этап 3: Унификация порядка операций (1 час)

1. Переместить списание баллов внутрь транзакции в `proposals/[id]/accept`
2. Протестировать атомарность операций

### Этап 4: Тестирование (2-3 часа)

1. Тест сценария прямой покупки
2. Тест сценария покупки через заявку (регрессия)
3. Тест уведомлений
4. Тест замораживания и размораживания баллов
5. Тест автоподтверждения (через 7 дней)

### Этап 5: Документация (1 час)

1. Обновить API документацию
2. Обновить комментарии в коде

**Общее время:** 5-7 часов (сокращено, т.к. не создаем виртуальные заявки)

## Риски и митигация

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Регрессия существующего функционала заявок | Средняя | Высокое | Тщательное тестирование, пошаговая реализация |
| Проблемы с уведомлениями | Низкая | Среднее | Логирование, graceful degradation |
| Несовместимость с существующими заказами | Низкая | Низкое | Миграция не требуется (requestId уже опциональный), проверки `if (order.requestId)` уже есть |

## Принятые решения

1. ✅ **Опциональный `requestId`:** Использовать существующую модель БД с опциональным `requestId`. Не создавать виртуальные заявки. Проверки `if (order.requestId)` уже существуют в коде.

2. ✅ **Уведомления:** Использовать общий текст уведомления для всех заказов (без кастомизации по источникам). Создать общую функцию `notifySpecialistAboutNewOrder`.

3. ✅ **UI:** 
   - В разделе "Найти клиентов" (для специалистов) виртуальные заявки не нужны
   - В дашборде специалиста показывать все заказы независимо от источника (это уже реализовано)

4. ✅ **Схема БД:** Флаг `isVirtual` не нужен, т.к. используем опциональный `requestId`. Заявки без связи с заказом остаются только реальными заявками.

5. ✅ **Обратная совместимость:** Существующие заказы без `requestId` останутся как есть. Миграция не требуется.

## Следующие шаги

1. ✅ **Согласование документа** (завершено)
2. Начало реализации по плану выше
3. После реализации: тестирование и деплой

